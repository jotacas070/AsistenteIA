// server/index.ts
import express3 from "express";

// server/routes.ts
import express from "express";
import { createServer } from "http";
import multer from "multer";

// server/storage.ts
import { randomUUID } from "crypto";
import { eq } from "drizzle-orm";

// server/lib/supabase.ts
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL environment variable is required");
}
var client = postgres(process.env.DATABASE_URL, {
  ssl: process.env.NODE_ENV === "production" ? "require" : "prefer",
  max: 1,
  prepare: false
});
var db = drizzle(client);

// shared/schema.ts
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, boolean, timestamp, jsonb, serial } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull()
});
var appConfig = pgTable("app_config", {
  id: serial("id").primaryKey(),
  appTitle: text("app_title").notNull().default("Asistente IA - Compras P\xFAblicas"),
  subtitle: text("subtitle").notNull().default("Armada de Chile"),
  primaryColor: text("primary_color").notNull().default("#1e3a8a"),
  fontSize: text("font_size").notNull().default("medium"),
  apiUrl: text("api_url").notNull(),
  apiKey: text("api_key").notNull(),
  requireUserPassword: boolean("require_user_password").notNull().default(false),
  userPassword: text("user_password"),
  adminPassword: text("admin_password").notNull(),
  updatedAt: timestamp("updated_at").notNull().default(sql`CURRENT_TIMESTAMP`)
});
var chatMessages = pgTable("chat_messages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  content: text("content").notNull(),
  sender: text("sender").notNull(),
  // 'user' or 'ai'
  attachments: jsonb("attachments"),
  // Array of file info
  createdAt: timestamp("created_at").notNull().default(sql`CURRENT_TIMESTAMP`)
});
var uploadedFiles = pgTable("uploaded_files", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  filename: text("filename").notNull(),
  originalName: text("original_name").notNull(),
  mimeType: text("mime_type").notNull(),
  size: text("size").notNull(),
  storageUrl: text("storage_url").notNull(),
  uploadedAt: timestamp("uploaded_at").notNull().default(sql`CURRENT_TIMESTAMP`)
});
var insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true
});
var insertConfigSchema = createInsertSchema(appConfig).omit({
  id: true,
  updatedAt: true
}).partial().extend({
  appTitle: z.string().optional(),
  subtitle: z.string().optional(),
  primaryColor: z.string().optional(),
  fontSize: z.string().optional(),
  apiUrl: z.string().optional(),
  apiKey: z.string().optional(),
  requireUserPassword: z.boolean().optional(),
  userPassword: z.string().nullable().optional(),
  adminPassword: z.string().optional()
});
var insertMessageSchema = createInsertSchema(chatMessages).omit({
  id: true,
  createdAt: true
});
var insertFileSchema = createInsertSchema(uploadedFiles).omit({
  id: true,
  uploadedAt: true
});

// server/storage.ts
var DbStorage = class {
  fallbackConfig;
  constructor() {
    this.fallbackConfig = {
      id: 1,
      appTitle: "Asistente IA - Compras P\xFAblicas",
      subtitle: "Armada de Chile",
      primaryColor: "#1e3a8a",
      fontSize: "medium",
      apiUrl: process.env.FLOWISE_API_URL || "https://your-flowise-instance.com/api/v1/prediction/your-id",
      apiKey: process.env.FLOWISE_API_KEY || "your-api-key-here",
      requireUserPassword: false,
      userPassword: null,
      adminPassword: process.env.ADMIN_PASSWORD || "change-me-immediately",
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.initializeConfig();
  }
  async initializeConfig() {
    try {
      const existingConfig = await db.select().from(appConfig).limit(1);
      if (existingConfig.length === 0) {
        await db.insert(appConfig).values({
          appTitle: "Asistente IA - Compras P\xFAblicas",
          subtitle: "Armada de Chile",
          primaryColor: "#1e3a8a",
          fontSize: "medium",
          apiUrl: process.env.FLOWISE_API_URL || "https://your-flowise-instance.com/api/v1/prediction/your-id",
          apiKey: process.env.FLOWISE_API_KEY || "your-api-key-here",
          requireUserPassword: false,
          userPassword: null,
          adminPassword: process.env.ADMIN_PASSWORD || "change-me-immediately"
        });
      }
    } catch (error) {
      console.log("Database not ready yet, using fallback config");
    }
  }
  async getUser(id) {
    const result = await db.select().from(users).where(eq(users.id, id)).limit(1);
    return result[0];
  }
  async getUserByUsername(username) {
    const result = await db.select().from(users).where(eq(users.username, username)).limit(1);
    return result[0];
  }
  async createUser(insertUser) {
    const result = await db.insert(users).values(insertUser).returning();
    return result[0];
  }
  async getConfig() {
    try {
      const result = await db.select().from(appConfig).limit(1);
      if (result.length === 0) {
        await this.initializeConfig();
        const newResult = await db.select().from(appConfig).limit(1);
        return newResult[0];
      }
      return result[0];
    } catch (error) {
      console.log("Database error, using fallback config:", error instanceof Error ? error.message : String(error));
      return this.fallbackConfig;
    }
  }
  async updateConfig(configUpdate) {
    try {
      const existingConfig = await this.getConfig();
      if (!existingConfig) {
        throw new Error("Config not found");
      }
      const result = await db.update(appConfig).set({ ...configUpdate, updatedAt: /* @__PURE__ */ new Date() }).where(eq(appConfig.id, existingConfig.id)).returning();
      return result[0];
    } catch (error) {
      console.log("Database error updating config, using fallback:", error instanceof Error ? error.message : String(error));
      this.fallbackConfig = { ...this.fallbackConfig, ...configUpdate, updatedAt: /* @__PURE__ */ new Date() };
      return this.fallbackConfig;
    }
  }
  async getMessages() {
    try {
      const result = await db.select().from(chatMessages).orderBy(chatMessages.createdAt);
      return result;
    } catch (error) {
      console.log("Database error getting messages:", error instanceof Error ? error.message : String(error));
      return [];
    }
  }
  async createMessage(insertMessage) {
    try {
      const result = await db.insert(chatMessages).values(insertMessage).returning();
      return result[0];
    } catch (error) {
      console.log("Database error creating message:", error instanceof Error ? error.message : String(error));
      return {
        id: randomUUID(),
        ...insertMessage,
        attachments: insertMessage.attachments || null,
        createdAt: /* @__PURE__ */ new Date()
      };
    }
  }
  async clearMessages() {
    try {
      await db.delete(chatMessages);
    } catch (error) {
      console.log("Database error clearing messages:", error instanceof Error ? error.message : String(error));
    }
  }
  async createFile(insertFile) {
    try {
      const result = await db.insert(uploadedFiles).values(insertFile).returning();
      return result[0];
    } catch (error) {
      console.log("Database error creating file:", error instanceof Error ? error.message : String(error));
      return {
        id: randomUUID(),
        ...insertFile,
        uploadedAt: /* @__PURE__ */ new Date()
      };
    }
  }
  async getFiles() {
    try {
      const result = await db.select().from(uploadedFiles).orderBy(uploadedFiles.uploadedAt);
      return result.reverse();
    } catch (error) {
      console.log("Database error getting files:", error instanceof Error ? error.message : String(error));
      return [];
    }
  }
  async deleteFile(id) {
    try {
      await db.delete(uploadedFiles).where(eq(uploadedFiles.id, id));
    } catch (error) {
      console.log("Database error deleting file:", error instanceof Error ? error.message : String(error));
    }
  }
};
var storage = new DbStorage();

// server/lib/flowise.ts
async function sendToFlowise(message, apiUrl, apiKey, uploads) {
  try {
    const payload = {
      question: message
    };
    if (uploads && uploads.length > 0) {
      payload.uploads = uploads;
    }
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      throw new Error(`Flowise API error: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    return {
      text: data.text || data.message || "No response from AI assistant",
      sourceDocuments: data.sourceDocuments,
      followUpPrompts: data.followUpPrompts
    };
  } catch (error) {
    console.error("Error calling Flowise API:", error);
    throw new Error("Failed to get response from AI assistant");
  }
}

// server/routes.ts
var upload = multer({
  dest: "uploads/",
  limits: {
    fileSize: 10 * 1024 * 1024
    // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "image/jpeg",
      "image/png",
      "image/gif",
      "text/plain"
    ];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type"), false);
    }
  }
});
async function registerRoutes(app2) {
  app2.get("/api/config", async (req, res) => {
    try {
      const config = await storage.getConfig();
      if (!config) {
        return res.status(404).json({ error: "Configuration not found" });
      }
      const { adminPassword, apiKey, ...safeConfig } = config;
      res.json(safeConfig);
    } catch (error) {
      console.error("Error getting config:", error);
      res.status(500).json({ error: "Failed to get configuration" });
    }
  });
  app2.put("/api/config", async (req, res) => {
    try {
      const validation = insertConfigSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ error: "Invalid configuration data" });
      }
      const updatedConfig = await storage.updateConfig(validation.data);
      const { adminPassword, apiKey, ...safeConfig } = updatedConfig;
      res.json(safeConfig);
    } catch (error) {
      console.error("Error updating config:", error);
      res.status(500).json({ error: "Failed to update configuration" });
    }
  });
  app2.post("/api/auth/admin", async (req, res) => {
    try {
      const { password } = req.body;
      const config = await storage.getConfig();
      if (!config || config.adminPassword !== password) {
        return res.status(401).json({ error: "Invalid admin password" });
      }
      res.json({ success: true, apiKey: config.apiKey });
    } catch (error) {
      console.error("Error authenticating admin:", error);
      res.status(500).json({ error: "Authentication failed" });
    }
  });
  app2.post("/api/auth/user", async (req, res) => {
    try {
      const { password } = req.body;
      const config = await storage.getConfig();
      if (!config) {
        return res.status(500).json({ error: "Configuration not found" });
      }
      if (!config.requireUserPassword) {
        return res.json({ success: true });
      }
      if (config.userPassword !== password) {
        return res.status(401).json({ error: "Invalid user password" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error authenticating user:", error);
      res.status(500).json({ error: "Authentication failed" });
    }
  });
  app2.get("/api/messages", async (req, res) => {
    try {
      const messages = await storage.getMessages();
      res.json(messages);
    } catch (error) {
      console.error("Error getting messages:", error);
      res.status(500).json({ error: "Failed to get messages" });
    }
  });
  app2.post("/api/messages", async (req, res) => {
    try {
      const validation = insertMessageSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ error: "Invalid message data" });
      }
      const userMessage = await storage.createMessage({
        content: validation.data.content,
        sender: "user",
        attachments: validation.data.attachments
      });
      const config = await storage.getConfig();
      if (!config) {
        return res.status(500).json({ error: "Configuration not found" });
      }
      try {
        const attachments = Array.isArray(validation.data.attachments) ? validation.data.attachments : validation.data.attachments ? [validation.data.attachments] : [];
        const aiResponse = await sendToFlowise(
          validation.data.content,
          config.apiUrl,
          config.apiKey,
          attachments
        );
        const aiMessage = await storage.createMessage({
          content: aiResponse.text,
          sender: "ai",
          attachments: null
        });
        res.json({
          userMessage,
          aiMessage
        });
      } catch (aiError) {
        console.error("Error from Flowise API:", aiError);
        const errorMessage = await storage.createMessage({
          content: "Lo siento, no pude procesar tu consulta en este momento. Por favor, intenta nuevamente m\xE1s tarde.",
          sender: "ai",
          attachments: null
        });
        res.json({
          userMessage,
          aiMessage: errorMessage,
          error: "AI service temporarily unavailable"
        });
      }
    } catch (error) {
      console.error("Error processing message:", error);
      res.status(500).json({ error: "Failed to process message" });
    }
  });
  app2.delete("/api/messages", async (req, res) => {
    try {
      await storage.clearMessages();
      res.json({ success: true });
    } catch (error) {
      console.error("Error clearing messages:", error);
      res.status(500).json({ error: "Failed to clear messages" });
    }
  });
  app2.post("/api/files", upload.array("files", 5), async (req, res) => {
    try {
      const files = req.files;
      if (!files || !Array.isArray(files)) {
        return res.status(400).json({ error: "No files uploaded" });
      }
      const uploadedFiles2 = [];
      for (const file of files) {
        const fileData = {
          filename: file.filename,
          originalName: file.originalname,
          mimeType: file.mimetype,
          size: file.size.toString(),
          storageUrl: `/uploads/${file.filename}`
        };
        const validation = insertFileSchema.safeParse(fileData);
        if (!validation.success) {
          console.error("Invalid file data:", validation.error);
          continue;
        }
        const savedFile = await storage.createFile(validation.data);
        uploadedFiles2.push(savedFile);
      }
      res.json(uploadedFiles2);
    } catch (error) {
      console.error("Error uploading files:", error);
      res.status(500).json({ error: "Failed to upload files" });
    }
  });
  app2.get("/api/files", async (req, res) => {
    try {
      const files = await storage.getFiles();
      res.json(files);
    } catch (error) {
      console.error("Error getting files:", error);
      res.status(500).json({ error: "Failed to get files" });
    }
  });
  app2.delete("/api/files/:id", async (req, res) => {
    try {
      await storage.deleteFile(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting file:", error);
      res.status(500).json({ error: "Failed to delete file" });
    }
  });
  app2.use("/uploads", express.static("uploads", {
    setHeaders: (res) => {
      res.header("Access-Control-Allow-Origin", "*");
    }
  }));
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express2 from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express2.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express3();
app.use(express3.json());
app.use(express3.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();
